// Generated by CoffeeScript 1.8.0
(function() {
  var SignalRBrowserWrapper,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  module.exports = SignalRBrowserWrapper = (function() {
    SignalRBrowserWrapper.prototype.observer_callbacks = {};

    SignalRBrowserWrapper.prototype.observer_registry = function(entity) {
      var callback, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
      if (this.observer_callbacks[entity._id]) {
        _ref = this.observer_callbacks[entity._id];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback(entity));
        }
        return _results;
      } else if (this.observer_callbacks[entity.Type]) {
        _ref1 = this.observer_callbacks[entity.Type];
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          callback = _ref1[_j];
          _results1.push(callback(entity));
        }
        return _results1;
      }
    };

    function SignalRBrowserWrapper(url, hubNames, jquery) {
      this.observer_registry = __bind(this.observer_registry, this);
      this.$ = jquery;
      this.url = url;
      this.hubs = {};
      this.signalr = null;
      this.connectionStatus = false;
    }

    SignalRBrowserWrapper.prototype.getHub = function(which, callback) {
      if (this.hubs[which]) {
        return callback(null, this.hubs[which]);
      } else {
        if (this.signalr == null) {
          this.signalr = this.$.hubConnection(this.url, {
            useDefaultPath: false
          });
          this.signalr.error(function(error) {
            console.log("Connection error" + error);
            return callback(error, null);
          });
        }
        this.hubs[which] = this.signalr.createHubProxy(which);
        this.hubs[which].on("error", function(data) {
          return console.log("Hub '" + which + "' has error" + data);
        });
        this.hubs[which].on("UpdateEntity", this.observer_registry);
        if (this.hubs[which].connection.state !== 1) {
          if (!this.connectionStatus) {
            return this.signalr.start().done((function(_this) {
              return function() {
                _this.connectionStatus = true;
                return _this.hubs[which].connection.start().done(function() {
                  return callback(null, _this.hubs[which]);
                });
              };
            })(this));
          } else {
            return this.hubs[which].connection.start().done((function(_this) {
              return function() {
                return callback(null, _this.hubs[which]);
              };
            })(this));
          }
        } else {
          return callback(null, this.hubs[which]);
        }
      }
    };

    SignalRBrowserWrapper.prototype.setCallback = function(id, futureCallback) {
      if (this.observer_callbacks[id] == null) {
        this.observer_callbacks[id] = [];
      }
      this.observer_callbacks[id].push(futureCallback);
    };

    SignalRBrowserWrapper.prototype.removeCallback = function(id, pastCallback) {
      var callback, temp, _i, _len, _ref;
      if (pastCallback === null) {
        this.observer_callbacks[id] = [];
      } else {
        temp = [];
        _ref = this.observer_callbacks[id];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          if (callback !== pastCallback) {
            temp.push(callback);
          }
        }
        this.observer_callbacks[id] = temp;
      }
    };

    SignalRBrowserWrapper.prototype.subscribe = function(hubName, method, observerId, subject, futureCallback, callback) {
      this.setCallback(subject, futureCallback);
      return this.getHub(hubName, function(error, hub) {
        if (error != null) {
          return callback(error, null);
        } else {
          if (hub != null) {
            hub.invoke(method, observerId);
          }
          return callback(null, hub);
        }
      });
    };

    SignalRBrowserWrapper.prototype.unsubscribe = function(hubName, method, observerId, subject, pastCallback, callback) {
      this.removeCallback(subject, pastCallback);
      if (this.observer_callbacks[subject].length === 0) {
        return this.getHub(hubName, function(error, hub) {
          if (error != null) {
            return callback(error, null);
          } else {
            if (hub != null) {
              hub.invoke(method, observerId);
            }
            return callback(null, hub);
          }
        });
      } else {
        return callback(null, true);
      }
    };

    return SignalRBrowserWrapper;

  })();

}).call(this);
